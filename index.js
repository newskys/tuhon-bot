require('dotenv').config();

const express = require('express');
const line = require('@line/bot-sdk');
const mongoose = require('mongoose');
const Bread = require('./model/bread');
const EscapeRoom = require('./model/escapeRoom');
const datefns = require('date-fns');
const koLocale = require('date-fns/locale/ko');
const { formatToTimeZone } = require('date-fns-timezone');

mongoose.connect(process.env.MONGO_URI)
.then(() => console.log('connected to mongodb'))
.catch(() => console.error(e));

let nextEscapeSchedule = null;

const config = {
  channelAccessToken: process.env.CHANNEL_ACCESS_TOKEN,
  channelSecret: process.env.CHANNEL_SECRET,
};

const timeZone = 'Asia/Seoul';
const formatFullDate = 'MMM Do (ddd) HH:mm';
const formatShortWeek = 'ddd';
const formatDayAndWeek = 'Do (dddd)';

const app = express();

// const text = 'ÌÅ¨Î°úÏôÄÏÉÅ';
// Bread.findOne()
//     .where('name').equals(text)
//     .sort('-date')
//     .then(
//       bread => {
//         const formattedWeek = datefns.format(bread.date, formatDayAndWeek, { locale: koLocale });
//         const isFuture = bread.date > new Date();
//         const diff = Math.abs(datefns.differenceInCalendarDays(bread.date, new Date()));
//         const extraText = isFuture ? `${diff}Ïùº ÎÇ®ÏïòÏäµÎãàÎã§.` : `${diff}Ïùº Í≤ΩÍ≥ºÌñàÏäµÎãàÎã§.`;
//         console.log('formattedWeek', formattedWeek);
//         console.log('isFuture', isFuture);
//         console.log(`üçû${text}üçû\n\n${formattedWeek} Îì±Ïû•${isFuture ? 'Ìï©ÎãàÎã§' : 'ÌñàÏäµÎãàÎã§'}!\n${extraText}`);
//         // return client.replyMessage(event.replyToken, {
//         //   type: 'text',
//         //   text: bread ? `üçû${'ÌÅ¨Î°úÏôÄÏÉÅ'}üçû\n\n${formattedWeek} Îì±Ïû•` : `Îπµ Ï†ïÎ≥¥Í∞Ä ÏóÜÏñ¥Ïöî!`,
//         // });
//       }
//     )
// Bread.find()
//     .where('date').gte(datefns.subDays(datefns.lastDayOfWeek(new Date()), 5))
//     .where('date').lte(datefns.lastDayOfWeek(new Date()))
//     .then(
//       breads => {
//         const weekBreads = breads.map(bread => {
//           const korWeekName = datefns.format(bread.date, formatShortWeek, { locale: koLocale });
//           return `${korWeekName}: ${bread.name}`;
//         });
//         console.log(weekBreads.join('\n'));
//       }
//     )

// const scheduledDate = datefns.parse('07/27 18:00', 'DD/MM HH:mm', new Date(datefns.getYear(new Date()), 0, 1));
// console.log('scheduledDate', scheduledDate);

app.get('/',(req, res) => {
  res.sendFile(__dirname + '/index.html');
});

app.post('/webhook', line.middleware(config), (req, res) => {
  Promise
    .all(req.body.events.map(handleEvent))
    .then((result) => res.json(result));
});

app.post('/callback', line.middleware(config), (req, res) => {
    if (req.body.destination) {
      console.log("Destination User ID: " + req.body.destination);
    }
  
    if (!Array.isArray(req.body.events)) {
      return res.status(500).end();
    }
  
    Promise.all(req.body.events.map(handleEvent))
      .then(() => res.end())
      .catch((err) => {
        console.error(err);
        res.status(500).end();
      });
  });
const client = new line.Client(config);

function handleEvent(event) {
//   if (event.type !== 'message' || event.message.type !== 'text') {
//     return Promise.resolve(null);
//   }

  const text = event.message.text;

  // if (text.startsWith('!ÎÇ¥Î∞©ÌÉàÏ∂ú')) {
  //   console.log('client', client);
  //   return client.replyMessage(event.replyToken, {
  //     type: 'text',
  //     text: 'Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.',
  //   })
  // }

  if (text === '!Ïò§ÎäòÏùòÎπµ') {
    Bread.findOne({date: datefns.startOfToday()})
    .then(
      bread => {
        console.log('bread', bread);
        return client.replyMessage(event.replyToken, {
          type: 'text',
          text: bread && bread.name ? `Ïò§ÎäòÏùò ÎπµÏùÄ üçû${bread.name}üçûÏûÖÎãàÎã§~` : 'ÏûÖÎ†•Îêú ÎπµÏù¥ ÏóÜÏñ¥Ïöî!',
        })
      }
    )
    .catch(err =>
      client.replyMessage(event.replyToken, {
        type: 'text',
        text: 'ÏûÖÎ†•Îêú ÎπµÏù¥ ÏóÜÏñ¥Ïöî!',
      })
    );
  }

  if (text === '!ÎÇ¥ÏùºÏùòÎπµ') {
    Bread.findOne({date: datefns.addDays(datefns.startOfToday(), 1)})
    .then(
      bread => {
        console.log('bread', bread);
        return client.replyMessage(event.replyToken, {
          type: 'text',
          text: bread && bread.name ? `ÎÇ¥ÏùºÏùò ÎπµÏùÄ üçû${bread.name}üçûÏûÖÎãàÎã§~` : 'ÎÇ¥ÏùºÏùò ÎπµÏù¥ ÏóÜÏñ¥Ïöî!',
        })
      }
    )
    .catch(err =>
      client.replyMessage(event.replyToken, {
        type: 'text',
        text: 'ÏûÖÎ†•Îêú ÎπµÏù¥ ÏóÜÏñ¥Ïöî!',
      })
    );
  }
  if (text === '!ÌÅ¨Î°úÏôÄÏÉÅ' || 
  text === '!ÍπúÎπ†Îâ¥' || 
  text === '!Î≤†Ïù¥Í∏Ä' || 
  text === '!Ïä§ÏΩò' ||
  text === '!ÎßàÎì§Î†å' ||
  text === '!Î≤à' || 
  text === '!ÌååÏù¥') {
    breadText = text.split('!')[1];
    Bread.findOne()
    .where('name').equals(breadText)
    .sort('-date')
    .then(
      bread => {
        console.log('bread', bread);
        const formattedWeek = datefns.format(bread.date, formatDayAndWeek, { locale: koLocale });
        const isFuture = bread.date > new Date();
        const diff = Math.abs(datefns.differenceInCalendarDays(bread.date, new Date()));
        const extraText = isFuture ? `${diff}Ïùº ÎÇ®ÏïòÏäµÎãàÎã§.` : `${diff}Ïùº Í≤ΩÍ≥ºÌñàÏäµÎãàÎã§.`;
        return client.replyMessage(event.replyToken, {
          type: 'text',
          text: bread ? `üçû${breadText}üçû\n\n${formattedWeek} Îì±Ïû•${isFuture ? 'Ìï©ÎãàÎã§' : 'ÌñàÏäµÎãàÎã§'}!\n${extraText}` : `Îπµ Ï†ïÎ≥¥Í∞Ä ÏóÜÏñ¥Ïöî!`,
        });
      }
    )
  }
  
  if (text === '!Îπµ') {
    Bread.find()
    .where('date').gte(datefns.subDays(datefns.lastDayOfWeek(new Date()), 5))
    .where('date').lte(datefns.lastDayOfWeek(new Date()))
    .then(
      breads => {
        const weekBreads = breads.map(bread => {
          const korWeekName = datefns.format(bread.date, formatShortWeek, { locale: koLocale });
          return `${korWeekName}: ${bread.name}`;
        });
        
        console.log('weekBreads', weekBreads);

        weekBreads.join('\n');
        return client.replyMessage(event.replyToken, {
          type: 'text',
          text: `üçûÏ£ºÍ∞Ñ Îπµüçû\n\n${weekBreads.join('\n')}`,
        })
      }
    )
    .catch(err =>
      client.replyMessage(event.replyToken, {
        type: 'text',
        text: 'ÏûÖÎ†•Îêú ÎπµÏù¥ ÏóÜÏñ¥Ïöî!',
      })
    );
  }

  if (text === '„Ñ±') {
    return client.replyMessage(event.replyToken, {
      type: 'text',
      text,
    });
  }

  if (text === '!Îã§ÏùåÎ∞©ÌÉàÏ∂ú') {
    try {
      EscapeRoom.findOne()
    .sort('date')
    .then(escapeRoom => {
      return client.replyMessage(event.replyToken, {
        type: 'text',
        text: `üß©Îã§Ïùå Î∞©ÌÉàÏ∂úüîê\n${escapeRoom.name}\n${escapeRoom.brand}\n\n${datefns.format(escapeRoom.date, formatFullDate, { locale: koLocale })}`,
        });
    });
    } catch (e) {
      console.err(e);
      return client.replyMessage(event.replyToken, {
        type: 'text',
        text: 'Îã§Ïùå Î∞©ÌÉàÏ∂úÏù¥ ÏóÜÏäµÎãàÎã§.',
        });
    }
  }

  if (text === '!test') {
    return client.replyMessage(event.replyToken, {
      "type": "bubble",
      "hero": {
        "type": "image",
        "url": "https://phinf.pstatic.net/dthumb/?src=%22https%3A%2F%2Fshopping-phinf.pstatic.net%2Fmain_8195821%2F81958214351.jpg%22&service=selective&type=f480_480_q90",
        "size": "full",
        "aspectRatio": "20:13",
        "aspectMode": "cover"
      },
      "body": {
        "type": "box",
        "layout": "vertical",
        "spacing": "md",
        "action": {
          "type": "uri",
          "uri": "https://naver.com"
        },
        "contents": [
          {
            "type": "text",
            "text": "Ïä§ÏΩò",
            "size": "xl",
            "weight": "bold"
          },
          {
            "type": "box",
            "layout": "vertical",
            "spacing": "sm",
            "contents": [
              {
                "type": "box",
                "layout": "baseline",
                "contents": [
                  {
                    "type": "icon",
                    "url": "https://phinf.pstatic.net/dthumb/?src=%22https%3A%2F%2Fshopping-phinf.pstatic.net%2Fmain_8195821%2F81958214351.jpg%22&service=selective&type=f480_480_q90"
                  },
                  {
                    "type": "text",
                    "text": "ÌÅ¨ÎûúÎ≤†Î¶¨ Ïä§ÏΩò",
                    "weight": "bold",
                    "margin": "sm",
                    "flex": 0
                  },
                  {
                    "type": "text",
                    "text": "1300‚Ç©",
                    "size": "sm",
                    "align": "end",
                    "color": "#aaaaaa"
                  }
                ]
              },
              {
                "type": "box",
                "layout": "baseline",
                "contents": [
                  {
                    "type": "icon",
                    "url": "https://phinf.pstatic.net/dthumb/?src=%22https%3A%2F%2Fshopping-phinf.pstatic.net%2Fmain_8195821%2F81958214351.jpg%22&service=selective&type=f480_480_q90"
                  },
                  {
                    "type": "text",
                    "text": "ÏñºÍ∑∏Î†àÏù¥ Ïä§ÏΩò",
                    "weight": "bold",
                    "margin": "sm",
                    "flex": 0
                  },
                  {
                    "type": "text",
                    "text": "1300‚Ç©",
                    "size": "sm",
                    "align": "end",
                    "color": "#aaaaaa"
                  }
                ]
              }
            ]
          },
          {
            "type": "text",
            "text": "9:30 ~ 11:00 / 15:00 ~ 17:00",
            "wrap": true,
            "color": "#aaaaaa",
            "size": "xxs"
          }
        ]
      }
    });
  }

  if (text.startsWith('!Î∞©ÌÉàÏ∂úÏ†ÄÏû•')) {
    const nextEscapeSchedule = text.split('!Î∞©ÌÉàÏ∂úÏ†ÄÏû•')[1].trim();
    const schedules = nextEscapeSchedule.split('\n');

    try {
      const targetDate = datefns.parse(schedules[0].trim(), 'MM-DD HH:mm', new Date(datefns.getYear(new Date()), 0, 1));
      const targetThemeName = schedules[1].trim();
      const targetBrand = schedules[2].trim();
      console.log('targetDate', targetDate);
      EscapeRoom.create({ date: targetDate, name: targetThemeName, brand: targetBrand, });  
      return client.replyMessage(event.replyToken, {
        type: 'text',
        text: 'Ïä§ÏºÄÏ§ÑÏùÑ Ï†ÄÏû•ÌñàÏäµÎãàÎã§.',
        });
    } catch (e) {
      console.err(e);
      return client.replyMessage(event.replyToken, {
        type: 'text',
        text: 'Ïä§ÏºÄÏ§ÑÏùÑ Ï†ÄÏû•ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§.',
        });
    }
  }

  if (text.startsWith('!ÎπµÏä§ÏºÄÏ§ÑÏ†ÄÏû•')) {
    try {
      const content = text.split('!ÎπµÏä§ÏºÄÏ§ÑÏ†ÄÏû•')[1].trim();
      let targetDate = datefns.subDays(datefns.lastDayOfWeek(new Date()), 5);

      const splited = content.split('\n');
      splited.forEach(name => {
        console.log('date', targetDate);
        console.log('name', name);
        Bread.create({date: targetDate, name});  
        targetDate = datefns.addDays(targetDate, 1);
      });

      return client.replyMessage(event.replyToken, {
        type: 'text',
        text: 'ÎπµÏä§ÏºÄÏ§ÑÏùÑ Ï†ÄÏû•ÌñàÏäµÎãàÎã§.',
        });
    } catch (e) {
      console.err(e);
      return client.replyMessage(event.replyToken, {
        type: 'text',
        text: 'ÎπµÏä§ÏºÄÏ§Ñ Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.',
        });
    }
  }

  if (text === '!Ïä§ÏºÄÏ§Ñ') {
    return client.replyMessage(event.replyToken, {
      type: 'text',
      text: nextEscapeSchedule || 'Îì±Î°ùÎêú Ïä§ÏºÄÏ§ÑÏù¥ ÏóÜÏñ¥Ïöî!',
      });
  }

  if (text === '@Ï±ÑÏû•Ìù¨' || text === '@ÏóÑÌö®ÏùÄ(Ïñ¥Î¨ò)' || text === '@Ïú§Ï£ºÏõê' || text === '@Ïã†Í∑úÏãù') {
    return client.replyMessage(event.replyToken, {
      type: 'text',
      text,
    });
  }

  return Promise.resolve(null);
}


const port = process.env.PORT || 3000;
app.listen(port);